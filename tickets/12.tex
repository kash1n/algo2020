\section {Графы, способы представления в программе. Поиск в глубину и поиск в ширину.}

\subsection* {Основные определения}

 {\bf Графом} называется двойка $(V, E)$, где V - множество вершин, E - мн-во ребер.\\
{\bf Ориентированный}: $E = \{(u,v) | u,v \in V\}$,\\
{\bf Неориентированный}: $E = \{(u,v) | u,v \in V\}/~, (u,v) ~ (v,u)$.\\
{\bf Степень вершины} в ориентированном:\begin{center} $\sum_{v\in V}d_{out}(v) = \sum_{v\in V}d_{in}(v) = |E|$, \end{center}
неориентированном: \begin{center} $\sum_{v\in V}d(v) = 2|E|$ \end{center}
{\bf Путь} от u к v: $e_1,e_2,\dots, e_k \in E, e_i = (u_{i-1}, u_i), u_0 = u, u_k = v$\\
{\bf Цикл}  $u_0 = u_k$\\
В {\bf связном} графе из любой вершины существует путь в другую вершину.\\
{\bf  Компонента связности}: максимальный связный подграф исходного графа.\\
{\bf Дерево}: связный неориентированный граф без циклов.


\subsection* {Известные задачи с графами}
\begin{itemize}
\item Задача о Кенигсбергскоих мостах: пройти по все мостам по одному разу. Поиск {\bf эйлерова пути}: пробегаем по всем ребрам по одному разу. Существование такого пути равносильно наличию не более 2 вершин нечетной степени.
\item Задача о поиске {\bf гамильтонова цикла}: пробегаем все вершины по одному разу. NP-полная задача.
\item Теорема Куратовского: граф планарен $\Leftrightarrow$ в нем нем подграфов $K_5$ или $K_{3,3}$.
\item Формула Эйлера для плоского графа на сфере с $g$ ручками $X$: 2-2g = V - E + F, где F - грани (G разбивает X на грани).
\item Проблема 4 красок: сколько нужно красок, чтобы раскрасить плоскую карту так, чтобы граничащие страны имели разные цвета.
\end{itemize}


\subsection* {Представление графа в программе}
\begin{itemize}
\item  {\bf Матрица смежности.} Используется булев массив $V \times V$, в котором в ячейке с координатами $v, w$ хранится $True$, если соответствующие вершины соединены ребром, иначе $False$. Такое хранение подходит для плотных графов, где $|E| \approx |V|^2$. Матрица необязательно симметрична в случае ориетированного графа.
\item  {\bf Списки смежности.} Используется массив $Adj$ из $|V|$ списков. Каждый список относится к отдельной вершине. В каждом списке в произвольном порядке находятся указатели на все смежные вершины соответствующей вершине. Такое хранение подходит для разреженных графов, где $|E| \ll |V|^2$.
\end{itemize}

\subsection* {Поиск в ширину BFS (breadth-first search)}
Пусть задан граф $G = (V,E)$ списком смежности и фиксирована начальная вершина s. Хотим найти путь из s в t. Алгоритм перечисляет все достижимые из s вершины в порядке возрастания расстояния от s. Расстоянием считается длина кратчайшего пути. В ширину, так как мы просматриваем сначала соседей, потом соседей соседей и т.д. У нас появляется разделение вершин на внутренние и фронтовые.

Код:
\begin{verbatim}
def BFS(G, s, t) :
   if s == t:
      return True
   visited = [False] * G.V.size() #массив посещений для каждой вершинки
   Q = queue() #очередь для хранения фронта
   visited[s] = True
   Q.push(s)
   while not Q.isEmpty():
      y = Q.pop()
      for x in G.neighbours(y):
         if x = t:
            return True
         if not visited[x]:
            visited[x] = True
            Q.push(x)
   return False
\end{verbatim}

\subsection* {Поиск в глубину DFS (depth-first search)}

Пусть задан граф $G = (V,E)$ списком смежности и фиксирована начальная вершина s. Хотим найти путь из s в t. Стратегия такова: идти вглубь пока это возможно, возвращаться назад и искать другой путь. Так делается, пока не найдем все вершины, достижимфые из исходной.

Код:
\begin{verbatim}
def DFS( G, s, t ) :
   if s == t:
      return True
   visited = array bool[ G.V.size()] #массив посещений для каждой вершинки
   return DFS( G, s, t, visited )
def DFS( G, s, t, visited )
   visited[s] = True
   for x in G.neighbours(y):
      if x = t:
         return True
      if not visited[x]:
         if DFS( G, x, t, visited ):
            return True
   return False
\end{verbatim}
{\bf Без рекурсии} Как легко видеть, если в BFS предварительно очередь заменить на стек, то получится DFS без рекурсии.\\
{\bf Полный обход всего графа}. Обработку вершины можно вставить в соответствующем месте (*) Код:
\begin{verbatim}
def DFS( G ) :
   visited = array bool[ G.V.size()] #массив посещений для каждой вершинки
   for x in G.V:
      DFS( G, x, visited )
def DFS( G, x, visited )
   visited[x] = True  *
   for y in G.neighbours(y):
      if not visited[y]:
         DFS( G, y, visited )
\end{verbatim}

Примеры см {\bf 155 стр. algo.pdf} или {\bf 446 стр. в Kormen\_algoritmy}
