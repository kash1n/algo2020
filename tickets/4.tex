\section {Оценка снизу количества сравнений при сортировке, быстрая сортировка Хоара, сложность в среднем и в худшем. Задача Дейкстры о голландском флаге, 3х-частное разбиение, эвристики выбора опорного элемента} 

\noindent {\bf Теорема.} Любой детерменированный алгоритм сортировки сравнением имеет в худшем случае $\Omega (n log n)$ \\

\noindent Количество перестановок в массиве из n элементов $= n!$ \\
Работу алгоритма на различных входных данных можно
представить в виде бинарного дерева. Каждое ветвление –
сравнение элементов массива. Если при любых входных данных
количество сравнений не больше S, то глубина дерева не больше
S.\\

\noindent Оценим теперь глубину этого дерева. По определению глубины дерева, в дереве глубины S кол-во путей $\le 2^S$. C другой стороны, так как сортировка должна работать для любого массива, то итоговое кол-во путей должно быть $\ge n!$. Поэтому $2^S \ge n!$, то есть $s \ge log_2 n! \ge log_2 \frac{n}{2}^{\frac{n}{2}} \ge k n log n$ для некоторого k. \\

\noindent{\bf Быстрая сортировка:}

\noindent Алгоритм состоит из трёх шагов:
\begin{enumerate}
    \item Выбрать элемент из массива. Назовём его опорным
    \item Разбиение: перераспределение элементов в массиве таким образом, что элементы меньше опорного помещаются перед ним, а больше или равные после
    \item Рекурсивно применить первые два шага к двум подмассивам слева и справа от опорного элемента. Рекурсия не применяется к массиву, в котором только один элемент или отсутствуют элементы
\end{enumerate}

\begin{verbatim}
procedure QuickSort(a[], left, right):
    // a[] - массив от 0 до n-1
    pivot = a[left]
    i = left + 1
    for j in [left + 1 .. right]:
        if a[j] < pivot:
            переставить a[j] и a[i]
            i++
        end
    end
    переставить a[left] и a[i-1]
    
    QuickSort(a, left, i - 2)
    QuickSort(a, i, right)
end
\end{verbatim} \\

\noindent Сложность
\begin{itemize}
    \item В худшем случае: $O(n^2)$
    \item В лучшем случае (опорный элемент - медиана):
    $$
    T(n) = 2T(\frac{n}{2})+ O(n) \Rightarrow T(n) = O(n log n)
    $$
    \item В «плохом» случае - опорный элемент делит массив в соотношении 99/100: $O(n log n)$
\end{itemize}

\noindent{\bf Теорема.} Сложность быстрой сортировки «в среднем» (при случайном выборе опорного элемента) равно $O (n log n)$

\noindent Док-во: есть в презентации, так что скатать можно оттуда, но если будет время - перенесу \\

\noindent Свойства:
\begin{itemize}
    \item Требует $\approx log n$ дополнительной памяти
    \item Не является устойчивым (может не сохранять порядок одинаковых элементов)
\end{itemize}

\noindent{\bf Трехчастное разбиение:} 

\noindent Заметим, что сложность быстрой сортировки на массиве из одинаковых элементов $= O(n^2)$. Решение - трехчастное разбиение:
\begin{itemize}
    \item a[i] < p для $0 \le i\le r$ - меньше опорного
    \item a[i] = p для $r + 1 \le i \le s$ - равны опорному
    \item a[i] > p для $s + 1 \le i \le n - 1$ - больше опорного
\end{itemize}

\begin{verbatim}
procedure QuickSort3Way(a[]):
    // a[] - массив от 0 до n-1
    перемешать (shuffle) массив a
    QuickSort3Way(a, 0, n-1)
end

procedure QuickSort3Way(a[], low, high):
    p = a[low]
    i = low + 1
    lt = low + 1
    gt = high
    while i <= gt:
        if a[i] < p:
            Exch(a, lt++, i++)
        else if a[i] > p:
            Exch(a, i, gt--)
        else
            i++
    end
    Exch(a, low, --lt)
    QuickSort3Way(a, low, lt - 1)
    QuickSort3Way(a, gt + 1, high)
end
\end{verbatim}

\noindent{\bf Задача о голландском флаге:} отсортировать массив, состоящий только из нулей, единиц и двоек. Как раз для этой задачи трехчастное разбиение идеально подходит.

\noindent{\bf Практические улучшения aka эвристики:}

\begin{enumerate}
    \item На массивах небольшого размера выгоднее использовать сортировку вставками
    \item Выбор опорного элемента: медиана из трех (median-of-3). Выбираем 3 случайны элемента и в качестве опорного берем второй по порядку (медиану).
    \item Выбор опорного элемента: выбираем 3 тройки случайных элементов, в
    каждой тройке находим медиану и в качестве опорного берем медиану медиан.
\end{enumerate}
