\section {Оценка снизу количества сравнений при сортировке, быстрая сортировка Хоара, сложность в среднем и в худшем. Задача Дейкстры о голландском флаге, 3х-частное разбиение, эвристики выбора опорного элемента} 

\noindent {\bf Теорема.} Любой детерменированный алгоритм сортировки сравнением имеет в худшем случае $\Omega (n \log n)$ \\

\noindent Количество перестановок в массиве из n элементов $= n!$ \\
Работу алгоритма на различных входных данных можно
представить в виде бинарного дерева. Каждое ветвление –
сравнение элементов массива. Если при любых входных данных
количество сравнений не больше S, то глубина дерева не больше
S.\\

\noindent Оценим теперь глубину этого дерева. По определению глубины дерева, в дереве глубины S кол-во путей $\le 2^S$. C другой стороны, так как сортировка должна работать для любого массива, то итоговое кол-во путей должно быть $\ge n!$. Поэтому $2^S \ge n!$, то есть $s \ge log_2 n! \ge log_2 \frac{n}{2}^{\frac{n}{2}} \ge k n \log n$ для некоторого k. \\

\noindent{\bf Быстрая сортировка:}

\noindent Алгоритм состоит из трёх шагов:
\begin{enumerate}
    \item Выбрать элемент из массива. Назовём его опорным
    \item Разбиение: перераспределение элементов в массиве таким образом, что элементы меньше опорного помещаются перед ним, а больше или равные после
    \item Рекурсивно применить первые два шага к двум подмассивам слева и справа от опорного элемента. Рекурсия не применяется к массиву, в котором только один элемент или отсутствуют элементы
\end{enumerate}

\begin{verbatim}
procedure QuickSort(a[], left, right):
    // a[] - массив от 0 до n-1
    pivot = a[left]
    i = left + 1
    for j in [left + 1 .. right]:
        if a[j] < pivot:
            переставить a[j] и a[i]
            i++
        end
    end
    переставить a[left] и a[i-1]
    
    QuickSort(a, left, i - 2)
    QuickSort(a, i, right)
end
\end{verbatim} \\

\noindent Сложность
\begin{itemize}
    \item В худшем случае: $O(n^2)$
    \item В лучшем случае (опорный элемент - медиана):
    $$
    T(n) = 2T(\frac{n}{2})+ O(n) \Rightarrow T(n) = O(n \log n)
    $$
    \item В «плохом» случае - опорный элемент делит массив в соотношении 99/100: $O(n \log n)$
\end{itemize}

\noindent{\bf Теорема.} Сложность быстрой сортировки «в среднем» (при случайном выборе опорного элемента) равно $O (n \log n)$

\noindent{\bf Доказательство:}
Пусть пространство элементарных событий $\Omega =$ \{все возможные последовательности опорных элементов\}, cлучайная величина $X(\omega) =$ \{количество выполняемых сравнений при последовательности опорных элементов $\omega$\}. Наша цель: мат. ожидание $M[X] = O (n \log n)$

\noindent Пусть $z_i$ - i-я порядковая статистика (стоит на i-м месте в отсортированном массиве), $X_{ij} (\omega)$ - кол-во сравнений $z_i$ и $z_j$ (заметим, что сравнений всегда либо 0, либо 1 вне зависимости от выборов опорных элементов). \\ 
\begin{equation*}
\begin{array}{c}
X(\omega) = \sum\limits_{i<j} X_{ij}(\omega) \\
M[X] = \sum\limits_{i<j} M[X_{ij}] = \sum\limits_{i<j} P[X_{ij} = 1]
\end{array}
\end{equation*}
$P[X_{ij} = 1] = \frac{2}{j - i + 1}$, так как рассмотрим все элементы в отсортированным массиве, стоящие с позиции i до позиции j (их $j - i + 1$ штук). В зависимости от того какой из этих элементов первый будет опорным возможны случаи. Если опорный будет i-й или j-й, то $X_{ij} = 1$, иначе эти два элемента попадут по разные стороны от опорного и их сравнение не произойдет, то есть $X_{ij} = 0$. Поэтому:
\begin{equation*}
\begin{array}{c}
M[X] = \sum\limits_{i<j} P[X_{ij} = 1] = \sum\limits_{i<j} \frac{2}{j - i + 1} = \\ 
= \sum\limits_{i=1}^{n-1} \sum\limits_{j=i+1}^{n} \frac{2}{j - i + 1}
\le 2n \sum\limits_{k=2}^{n} \frac 1 k \le 2nlnn
\end{array}
\end{equation*}

\noindent Свойства:
\begin{itemize}
    \item Требует $\approx \log n$ дополнительной памяти
    \item Не является устойчивым (может не сохранять порядок одинаковых элементов)
\end{itemize}

\noindent{\bf Трехчастное разбиение:} 

\noindent Заметим, что сложность быстрой сортировки на массиве из одинаковых элементов $= O(n^2)$. Решение - трехчастное разбиение:
\begin{itemize}
    \item a[i] < p для $0 \le i\le r$ - меньше опорного
    \item a[i] = p для $r + 1 \le i \le s$ - равны опорному
    \item a[i] > p для $s + 1 \le i \le n - 1$ - больше опорного
\end{itemize}

\begin{verbatim}
procedure QuickSort3Way(a[]):
    // a[] - массив от 0 до n-1
    перемешать (shuffle) массив a
    QuickSort3Way(a, 0, n-1)
end

procedure QuickSort3Way(a[], low, high):
    p = a[low]
    i = low + 1
    lt = low + 1
    gt = high
    while i <= gt:
        if a[i] < p:
            Exch(a, lt++, i++)
        else if a[i] > p:
            Exch(a, i, gt--)
        else
            i++
    end
    Exch(a, low, --lt)
    QuickSort3Way(a, low, lt - 1)
    QuickSort3Way(a, gt + 1, high)
end
\end{verbatim}

\noindent{\bf Задача о голландском флаге:} отсортировать массив, состоящий только из нулей, единиц и двоек. Как раз для этой задачи трехчастное разбиение идеально подходит.

\noindent{\bf Практические улучшения aka эвристики:}

\begin{enumerate}
    \item На массивах небольшого размера выгоднее использовать сортировку вставками
    \item Выбор опорного элемента: медиана из трех (median-of-3). Выбираем 3 случайны элемента и в качестве опорного берем второй по порядку (медиану).
    \item Выбор опорного элемента: выбираем 3 тройки случайных элементов, в
    каждой тройке находим медиану и в качестве опорного берем медиану медиан.
\end{enumerate}
