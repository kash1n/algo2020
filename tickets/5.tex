\section {Алгоритмы нахождения $k$-й порядковой статистики - вероятностный и детерминированный.
Метод сортировки TimSort.}

\noindent\textbf{Определение}\\
k-ой порядковой статистикой набора элементов линейно упорядоченного множества называется такой его элемент, который является $k$-ым элементом набора в порядке сортировки.

\subsection{Модфифкация Quicksort (basic)}
\noindent\textbf{Описание алгоритма}:\\
Будем использовать процедуру рассечения массива элементов из алгоритма сортировки QuickSort. Пусть нам надо найти $k$-ую порядковую статистику, а после рассечения опорный элемент встал на позицию m. Возможно три случая:
\begin{itemize}
    \item $k = m$: Порядковая статистика найдена.\\
    \item $k < m$: Рекурсивно ищем $k$ -ую статистику в первой части массива.\\
	\item $k > m$: Рекурсивно ищем $(k - m -1)$ -ую статистику во второй части массива.\\
\end{itemize}
\noindent\textbf{Анализ времени работы}: $O(n)$
\subsection{Поиск k-ой порядковой статистики за линейное время(BFPRT)}

\noindent\textbf{Идея}:\\
Этот алгоритм является модификацией алгоритма поиска $k$-ой порядковой статистики. Важное отличие заключается в том, что время работы алгоритма в наихудшем случае — $O(n)$, где $n$ — количество элементов в множестве. Главная идея алгоритма заключается в том, чтобы гарантировать хорошее разбиение массива. Алгоритм выбирает такой рассекающий элемент, что количество чисел, которые меньше рассекающего элемента, не менее $\frac{3n}{10}$. Элементов же больших опорного элемента, также не менее $\frac{3n}{10}$. Благодаря этому алгоритм работает за линейное время в любом случае. 

\noindent\textbf{Описание алгоритма}:\\
\begin{itemize}
    \item[1] Все $n$ элементов входного массива разбиваются на группы по пять элементов, в последней группе будет $n mod 5$ элементов. Эта группа может оказаться пустой при $n$ кратным 5.
    \item[2] Сначала сортируется каждая группа, затем из каждой группы выбирается медиана.
	\item[3] Путем рекурсивного вызова шага определяется медиана $x$ из множества медиан (верхняя медиана в случае чётного количества), найденных на втором шаге. Найденный элемент массива $x$ используется как рассекающий (за $i$ обозначим его индекс).
	\item[4] Массив делится относительно рассекающего элемента x.
	\item[5] Если $i = k$, то возвращается значение $x$. Иначе запускается рекурсивно поиск элемента в одной из частей массива: $k$-ой статистики в левой части при $i > k$ или $(k - i - 1)$-ой статистики в правой части при $i < k$.
\end{itemize}

\noindent\textit{Источник}: \href{http://neerc.ifmo.ru/wiki}{Тыкай Алгоритмы и стркутуры данных-> алгоритмы поиска}

\subsection{Timsort}
\noindent\textbf{Идея}:\\
Алгоритм Timsort состоит из нескольких частей: 
\begin{itemize}
    \item[1] Входной массив разделяется на подмассивы фиксированной длины, вычисляемой определённым образом.
    \item[2]  Каждый подмассив сортируется сортировкой вставками, сортировкой пузырьком или любой другой устойчивой сортировкой.
	\item[3]  Отсортированные подмассивы объединяются в один массив с помощью модифицированной сортировки слиянием.
\end{itemize}


\noindent\textbf{Обозначения}:\\
Алгоритм Timsort состоит из нескольких частей: 
\begin{itemize}
    \item[1] $n$ — размер входного массива.
    \item[2]  $run$ — подмассив во входном массиве, который обязан быть упорядоченным одним из двух способов: строго по убыванию или нестрого по возрастанию
	\item[3]  $minrun$ — минимальный размер подмассива, описанного в предыдущем пункте.
\end{itemize}


\noindent\textbf{Общая схема}:\\

\begin{itemize}
    \item[1] Определяем $minrun$, текущая позиция $= 1$
    \item[2] Находим $run$, начинающийся с текущей позиции
	\item[3] Если $run$ убывающий \--- переворачиваем
	\item[4] Если $run$ короче $minrun$ \--- дополняем и сортируем вставками
	\item[5] Добавляем в стек (начало подмассива, длина)
	\item[6] Проверяем условия баланса стека 
	\item[7] Если не дошли до конца массива \--- переходим к 2
	\item[8] Сливаем подмассивы, хранящиеся в стеке
\end{itemize}

\noindent\textbf{Слияние}:\\

\begin{itemize}
    \item[1]  Создается пустой стек пар < индекс начала подмассива, размер подмассива >.
    \item[2] Берется первый упорядоченный подмассив.
	\item[3] Добавляется в стек пара данных < индекс начала текущего подмассива, его размер >.
	\item[4]  Пусть $X$,$Y$,$Z$ — длины верхних трех интервалов, которые лежат в стеке. Причем $X$ — это последний элемент стека (если интервалов меньше трёх, проверяем лишь условия с оставшимися интервалами).
	\item[5] Повторяем пока выражение $(Z>X+Y \wedge Y>X)$ не станет истинным: если размер стека не меньше 2 и $Y \leq X$ — сливаем $X$ c $Y$, а если размер стека не меньше 3 и $Z \leq X+Y$ — сливаем $Y$ c $min(X,Z)$. 
	\item[6]  Переходим к шагу 3 
\end{itemize}
	
	\noindent\textbf{Описание процедуры слияния}:\\

\begin{itemize}
    \item[1]  Создается временный массив в размере меньшего из сливаемых подмассивов.
    \item[2]  Меньший из подмассивов копируется во временный массив, но надо учесть, что если меньший подмассив — правый, то ответ (результат сливания) формируется справа налево. Дабы избежать данной путаницы, лучше копировать всегда левый подмассив во временный. На скорости это практически не отразится. 
	\item[3] Ставятся указатели текущей позиции на первые элементы большего и временного массива.
	\item[4]  На каждом шаге рассматривается значение текущих элементов в большем и временном массивах, берется меньший из них, копируется в новый отсортированный массив. Указатель текущего элемента перемещается в массиве, из которого был взят элемент.
	\item[5] Предыдущий пункт повторяется, пока один из массивов не закончится.
	\item[6] Все элементы оставшегося массива добавляются в конец нового массива.
\end{itemize}

\noindent\textit{Есть модификация слияния - Galloping mode}

\noindent\textbf{Время}: $O(n log n)$