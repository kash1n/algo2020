\section{Хеш-таблицы, реализация методом цепочек и открытой адресацией.}

\subsection*{хеш-таблицы}

{\bf Ассоциативный массив} - структура данных, хранящая наборы типа <Key, Value>. 
Предполагается, что ассоциативный массив не может хранить две пары с одинаковыми ключами (на практике этого добиться сложно).
Интерпретация ассоциативного массива - отображение $value: Key \rightarrow Value$.

Операции (или интерфейс):
\begin{itemize}
\item Вставка (добавление)
\item Поиск по ключу (взятие значения или проверка)
\item Удаление по ключу
\end{itemize}

{\bf Хеш-таблица} - структура, реализующая ассоциативный массив.

{\bf Важные свойства} хеш-таблиц состоит в том, что, при некоторых разумных допущениях, в среднем:
\begin{itemize}
\item Вставка: O(1)
\item Поиск по ключу: O(1)
\item Удаление по ключу: O(1)
\item Память: O(n)
\end{itemize}

Отображение $h: U \rightarrow \{0, 1, ..., k\}$, где $U$ - множество ключей называется {\bf хеш-функций}.
Если $h$ - хеш-функция, то можно считать, что $value(u) = array[h(u)]$, где $array$ - массив размера $m$.

Пример:
$"abc" \rightarrow ord(a)*ord(b)*ord(c)$.

Код:
\begin{verbatim}
public int hash(char[] value) 
{
	int h = 0;
	for (int i = 0; i < value.length; i++) 
	{
		h = 31 * h + value[i];
	}
	return h;
}
\end{verbatim}

В таком определении могут возникнуть {\bf коллизии} $h(u_1) = h(u_2)$, где $u_1, u_2 \in U$.

\subsection*{Разрешение коллизий. Метод цыпочек}
Вычисляем $h(u)$. В случае коллизии пихаем элемент в "соседнюю" (это понятие резиновое, например правая или вторая справа. В общем случае это {\bf последовательность проб} $h_0(x), h_1(x), …, h_{n-1}(x)$) ячейку.
Как искать? - пробегаем все соседнии ячейки, пока ключ совпадает.

\subsubsection*{Теорема}
Математическое ожидание сложности неудачного поиска
при условии простого равномерного хеширования равна
$O(1 + \alpha)$, где $\alpha$ - коэффициент заполнения таблицы.
$\alpha = \frac{n}{m}$, где $m$ - число ячеек. 

\subsection*{Разрешение коллизий. Открытой адресации}
$array[h(u)]$ - список. В случае коллизий append-им пару (ключ, значение) туда.


\subsubsection*{Теорема}
Математическое ожидание сложности неудачного поиска
при условии простого равномерного хеширования равна
$O(\frac{1}{1-\alpha})$, где $\alpha < 1$ - коэффициент заполнения таблицы.
$\alpha = \frac{n}{m}$, где $m$ - число ячеек. 

Доказательство:

Пусть $X$ - количество проверок при неуспешном поиске.
$$E[X] = \sum\limits_{i=0}^{\infty}iP\{X = i\} = \sum\limits_{i=0}^{\infty}iP(\{X\ge i\} - P\{X\ge i+1\}) = \sum\limits_{i=0}^{\infty}P\{X \ge i\}$$
$$E[X] = \sum\limits_{i=1}^{\infty}P{X \ge i}\ge\sum\limits_{i=0}^{\infty}\alpha^i = \frac{1}{1-\alpha}$$ 

\subsection*{Защита хеш-функций от атак}
Если недоброжелателю известна хеш-функция $h$, то он может нагенерировать очень много коллизий, что приведет к работе алгоритма за $O(n)$ (так называемая $атака на сервер.$)
{\bf Универсальным хешированием} называется решение такой проблемы - просто выбираем случайную хеш-функцию из какого-то множества.
