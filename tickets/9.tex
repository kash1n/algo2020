\section{B-деревья.}

{\bf Применение}: часто бывают ситуации, в которых чтение узла дерева занимает относительно большое время, и при этом чтение выполняется поблочно, для этого хочется уменьшить число узлов и увеличить их размер.
(Файловые системы, базы данных)

{\bf Структура:} B-деревья обобщают 2-3 - деревья: в вершинах дерева хранится от $\frac{M}{2}$ до $M-1$ ключей, за исключением корневой вершины, в которой может храниться от $0$ до $M-1$ ключей. 
В каждой вершине - 2 массива: отсортированный массив ключей и массив данных (на 1 больший по размеру). "Внешние узлы хранят ключи (+данные), внутренние узлы хранят ключи для обеспечения поиска". 

Моя интерпретация:
В узлах, не являющихся листами, $i$-ое значение данных, является ссылкой на поддерево, содержащее ключи в интервале $(K_{i-1}, K_i)$, для $i = 0$ интервал - $(-\inf, K_0)$, для последнего $i = s+1$ интервал - $(K_s, +\inf)$. В узлах, являющихся листами, хранятся реальные данные. 

B-дерево - сбалансированное, откуда сложность поиска от $log_{M-1}{N}$ до $log_{M/2}{N}$. Опишем кратко операции поиска, добавления и удаления элемента.

\subsection*{Поиск}
Поиск ключа: находясь в узле проверяем, есть ли искомый ключ в отсортированном массиве ключей узла: если - да, то ключ найден, иначе  - определяем между какими ключами узла лежит искомый и спускаемся в соответствующее поддерево.

\subsection*{Добавление}
Вначале определим функцию, которая добавляет ключ K к поддереву потомков узла $x$.

Если $x$ — не лист,
	\begin{itemize}
        \item Определяем интервал, где должен находиться K. Пусть $y$ — соответствующий потомок.
        \item Рекурсивно добавляем K к дереву потомков $y$.
        \item Если узел $y$ полон, то есть содержит $M-1$ ключей, расщепляем его на два. Узел $y_1$ получает первые $\frac{M}{2}-1$ из ключей $y$ и первые $\frac{M}{2}$ его потомков, а узел $y_2$ — последние $\frac{M}{2}-1$ из ключей $y$ и последние $\frac{M}{2}$ его потомков. Средний по порядку из ключей узла $y$ попадает в узел $x$, а указатель на $y$ в узле $x$ заменяется указателями на узлы $y_1$ и $y_2$.
	\end{itemize}    	
	
	Если $x$ — лист, просто добавляем туда ключ K (при переполнении аналогично расщепляем и выталкиваем средний по порядку элемент вверх)

Теперь определим добавление ключа K ко всему дереву.

    Добавим K к дереву потомков корневого узла.

    Если Root содержит теперь $M-1$ ключей, расщепляем его на два. Узел $R_{1}$ получает первые $\frac{M}{2}-1$ из ключей Root и первые $\frac{M}{2}$ его потомков, а узел $R_{2}$ — последние $\frac{M}{2}-1$ из ключей Root и последние $\frac{M}{2}$ его потомков. Средний по порядку из ключей узла Root попадает вo вновь созданный узел, который становится корневым. Узлы $R_{1}$ и $R_{2}$ становятся его потомками.

\subsection*{Удаление}
(На лекциях, кажется, не было, но вот краткое описание:)

Если корень одновременно является листом, то есть в дереве всего один узел, мы просто удаляем ключ из этого узла. В противном случае сначала находим узел, содержащий ключ, запоминая путь к нему. Пусть этот узел — $x$.

Если $x$ — лист, удаляем оттуда ключ. Если в узле $x$ осталось не меньше $t-1$ ключей, мы на этом останавливаемся. Иначе мы смотрим на количество ключей в следующем узле (брате), а потом в предыдущем узле (брате). Если следующий узел есть, и в нём не менее $t$ ключей, мы добавляем в $x$ ключ-разделитель между ним и следующим узлом из родительского узла, а на его место ставим первый ключ следующего узла, после чего останавливаемся. Если это не так, но есть предыдущий узел, и в нём не менее $t$ ключей, мы добавляем в $x$ ключ-разделитель между ним и предыдущим узлом, а на его место ставим последний ключ предыдущего узла, после чего останавливаемся. Наконец, если и с предыдущим ключом не получилось, мы объединяем узел $x$ со следующим или предыдущим узлом, и в объединённый узел перемещаем ключ, разделяющий два узл в родительском узле. При этом в родительском узле может остаться только $t-2$ ключей. Тогда, если это не корень, мы выполняем аналогичную процедуру с ним. Если мы в результате дошли до корня, и в нём осталось от 1 до $t-1$  ключей, делать ничего не надо, потому что корень может иметь и меньше $t-1$ ключей. Если же в корне не осталось ни одного ключа, исключаем корневой узел, а его единственный потомок делаем новым корнем дерева.


Если $x$ — не лист, а K — его $i$-й ключ, удаляем самый правый ключ из поддерева потомков $i$-го потомка $x$, или, наоборот, самый левый ключ из поддерева потомков $i+1$-го потомка $x$. После этого заменяем ключ K удалённым ключом. Удаление ключа происходит так, как описано в предыдущем абзаце. 

