%main.tex
\documentclass[specialist, subf, href, colorlinks=true, 12pt, times, mtpro, final]{disser}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{a4wide}
\usepackage{mathtext}
\usepackage{amsbsy}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{tikz}
\usepackage{verbatim}
\usepackage{graphicx}

\definecolor{faded}{gray}{0.6}
\def\note{\textcolor{faded}}
 
\begin{document}

\tableofcontents

\newpage
{\Large \bf Программа экзамена (осень 2020)}

\begin{enumerate}
{\small
\item Сложность алгоритмов, бинарный поиск, сортировка выбором и вставками
\item Сортировка слиянием. Основная теорема для метода «разделяй и властвуй».
\item Алгоритм Карацубы умножения чисел, алгоритм Штрассена умножения матриц. Быстрое преобразование Фурье.
\item Оценка снизу количества сравнений при сортировке, быстрая сортировка Хоара, сложность в среднем и в худшем. Задача Дейкстры о голландском флаге, 3х-частное разбиение, эвристики выбора опорного элемента.
\item Алгоритмы нахождения k-й порядковой статистики - вероятностный и детерминированный. Метод сортировки TimSort.
\item Абстрактные типы данных, интерфейс и реализация, стек и очередь - реализация связанным списком и массивом.
\item Ассоциативные массивы, бинарные деревья поиска.
\item Сбалансированные деревья, 2-3 и красно-черные деревья.
\item B-деревья.
\item Хеш-таблицы, реализация методом цепочек и открытой адресацией.
\item Распределенные хеш-таблицы. Фильтр Блума.
\item Графы, способы представления в программе. Поиск в глубину и поиск в ширину.
\item Топологическая сортировка. Алгоритм Косарайю поиска сильносвязанных компонент.
}
\end{enumerate}


\section {Сложность алгоритмов, бинарный поиск, сортировка выбором и вставками}
\noindentПусть $\Omega_{n}$ – множество всех допустимых наборов входных данных размера $n$.\\
$T(\omega)$ – {\bf сложность} (количество операций) алгоритма $A$ на входных данных $\omega \in \Omega_{n}$.\\
Сложность {\bf в худшем случае}:
$$
  T(n) = \max\limits_{\omega \in \Omega_{n}}T(\omega)
$$
Сложность {\bf в среднем (average)}:
$$
  T_{avg}(n) = \frac{1}{|\Omega_{n}|}\sum\limits_{\omega \in \Omega_{n}}T(\omega)
$$
\note{// Отступление про $O$-нотацию.}\\
{\bf Поиск элемента в массиве (бинарный поиск):}\\
Дано: отсортированный массив \texttt{a[]}, элемент \texttt{x}\\
Требуется: определить, содержится ли \texttt{x} в \texttt{a[]}\\
Идея:
\begin{enumerate}
\item Делим массив пополам
\item Сравниваем \texttt{x} с центральным элементом \texttt{a[mid]}
\begin{itemize}
\item \texttt{x = a[mid]}? – нашли
\item \texttt{x < a[mid]}? – ищем в нижней части массива
\item \texttt{x > a[mid]}? – ищем в верхней части массива
\end{itemize}
\end{enumerate}
Код:\\
\begin{verbatim}
procedure BinarySearch( a[], x ):
    // a[] - array from 0 to n-1
    low = 0
    high = n-1
    while low <= high:
        mid = low + (high - low) / 2
        if a[mid] < x:
            low = mid + 1
        else if a[mid] > x:
            high = mid - 1
        else
            return mid
    end
    return -1
end
\end{verbatim}
Пусть $n \le 2^k$ ($k = [\log n]$). Итераций: $k + 1$. На каждой итерации: $O(1)$. Итого:
$O(\log n)$.\\
{\bf Сортировка выбором (Selection sort):}\\
Шаги алгоритма:
\begin{enumerate}
\item Находим номер минимального (или максимального, смотря что хотим) значения в текущем списке
\item Производим обмен этого значения со значением первой неотсортированной позиции (обмен не нужен, если минимальный элемент уже находится на данной позиции)
\item Теперь сортируем хвост списка, исключив из рассмотрения уже отсортированные элемент
\end{enumerate}
Код:
\begin{verbatim}
procedure SelectionSort( a[] ):
    // a[] - array from 0 to n-1
    for i in [1..n-1]:
        j = index of max element in a[0..n-i]
    swap (a[j], a[n-i])
    end
end
\end{verbatim}
Количество сравнений:
$$
(n-1)+(n-2)+...+1 = \frac{n(n-1)}{2}
$$
Итого: $O(n^2)$.\\
{\bf Сортировка вставками (Insertion sort):}\\
Идея: для каждого элемента ищем место в отсортированной части массива, в которое его нужно вставить.\\
Код:
\begin{verbatim}
procedure InsertionSort( a[] ):
    for i in [1..n-1]:
        j = i, t = a[j]
        while j > 0 && t < a[j-1]:
            a[j] = a[j-1]
            j = j-1
        end
        a[j] = t
    end
end
\end{verbatim}
В лучшем случае сравнений
$$
1 + 1 + . . . + 1 = n - 1
$$
в худшем случае
$$
1 + 2 + . . . + (n - 1) = \frac{n(n - 1)}{2}
$$

\section {Сортировка слиянием. Основная теорема для метода «разделяй и властвуй»}
\include {tickets/10}
 
\end{document}
